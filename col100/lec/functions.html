<h3>Variable scope</h3>
<ul>
<li> <em>formal parameter</em> gets bound to the value of <em>actual parameter</em> when a function is called.
<li> new <em>scope</em>/<em>frame</em>/<em>environment</em> is created when enter a function</li>
<li><em>scope</em> is mapping of names to objects</li>
</ul>
<pre>
#function definition
def f(x):  #x is a formal parameter
  x = x + 1
  print('in f(x), x =', x)
  return x

x = 3
z = f(x) #x is the actual parameter of this function call. return value is assigned to z
</pre>
At the instant when execution is at the start of <code>f</code>, there are two scopes: global scope and f scope. The global scope maps <code>f -&gt; some code</code>, <code>x -&gt; 3</code> and <code>z</code> is currently undefined.  In <code>f scope</code>, <code>x -&gt; 3</code>

<p>At the instant when execution is at the end of <code>f</code>:
The global scope maps <code>f -&gt; some code</code>, <code>x -&gt; 3</code> and <code>z</code> is currently undefined.  In <code>f scope</code>, <code>x -&gt; 4</code>

<p>At the instant when execution has returned from <code>f</code> and <code>z</code> has been assigned: there is only one scope, which is the global scope.
The global scope maps <code>f -&gt; some code</code>, <code>x -&gt; 3</code> and <code>z -&gt; 4</code>.  Notice that <code>z</code> is assigned the value <em>returned</em> (using the <code>return</code> keyword) by <code>f</code>.

<p>Consider the following (buggy) function that does not contain a <code>return</code> statement:
<pre>
#function definition
def f(x):  #x is a formal parameter
  x = x + 1

x = 3
z = f(x) #x is the actual parameter of this function call. return value is assigned to z
</pre>
<ul>
<li> Python returns the value <code>None</code> if no <code>return</code> given</li>
<li> represents the absence of a value</li>
</ul>

<p><code>return</code> vs. <code>print</code>
<table>
<tr>
<th><code>return</code></th>
<th><code>print</code></th>
</tr>
<tr>
<td>
<code>return</code> only has meaning inside a function
</td>
<td>
<code>print</code> can be used outside functions
</td>
</tr>
<tr>
<td>
only one <code>return</code> executed inside a function
</td>
<td>
can execute many print statements inside a function
</td>
</tr>
<tr>
<td>
code inside function but after return statement not executed
</td>
<td>
code inside function can be executed after a print statement
</td>
</tr>
<tr>
<td>
has a value associated with it, <em>given to function caller</em>
</td>
<td>
has a value associated with it, <em>outputted</em> to the console
</td>
</tr>
</table>

<p><b>Functions as arguments</b>:
<ul>
<li> arguments can take on any type, even functions!</li>
</ul>
Example:
<pre>
def func_a(a):
  print 'inside func_a'

def func_b(y):
  print 'inside func_b'
  return y

def func_c(z):
  print 'inside func_c'
  return z()

print func_a()  # func_a takes no parameters
print 5 + func_b(2)  # func_b takes one parameter
print func_c(func_a)  # func_c takes one parameter, another function
</pre>

<p>Show global scope and func_a scope while <code>func_a</code> is executing.  Notice that it returns <code>None</code>, which gets printed.  Similarly, <code>func_b</code> returns <code>2</code> and so <code>7</code> is printed.

<p>Show three scopes: global, <code>func_c</code>, and <code>func_a</code>.

<p><b>Scope example</b>
<ul>
<li> inside a function, <em>can access</em> a variable defined outside.</li>
<li> inside a function, <em>cannot modify</em> a variable defined outside.
<ul>
<li>This can be done using global variables, but is frowned upon.</li>
</ul>
</li>
</ul>

<p>Examples:
<ul>
<li>Outside variable re-defined in scope and then modified: OK because these are two different <code>x</code> objects
<pre>
def f(y):
  x = 1  #x is re-defined in scope of f (different object)
  x += 1
  print(x)

x = 5  #x is defined outside the scope of f
f(x)
print(x) #prints the outer x object
</pre>
</li>
<li><code>x</code> inside <code>g</code> is picked up from scope that called function <code>g</code>.
<pre>
def g(y):
  print(x)  #x from outside g
  print(x+1) #x from outside g

x = 5
g(x)
print(x) #prints the outer (and only) x object
</pre>
<code>x</code> inside <code>g</code> is picked up from scope that called function <code>g</code>.
</li>
<li>Error if <code>x</code> is used with a read/write operator (where the read happens first) in a scope, even if it was defined in an outer scope.
<pre>
def h(y):
  x += 1

x = 5
h(x)
print(x)  #does not reach here
</pre>
This yields <code>UnboundLocalError: local variable 'x' referenced before assignment</code>.  Would have been ok if we had done <code>x = x + 1</code> instead of <code>x += 1</code> --- the former reads the outer x and defines an inner x; the latter tries to read the inner x before it has been defined!
</li>
</ul>

<p>More complex example:
<pre>
def g(x):
  def h():
    x = 'abc'
  x = x + 1
  print('g: x = ', x)
  h()
  return x

x = 3
z = g(x)
</pre>
Global scope has <code>g -&gt; some code</code> and <code>x -&gt; 3</code>. The
<code>g</code> scope has <code>x -&gt; 4</code> (reads from the outer object and defines an inner object) and <code>h -&gt; some code</code>.  This behaviour of reading from the outer scope and defining a new variable in the inner scope, is no longer possible in recent versions of Python (to avoid programming errors). The <code>h</code> scope has <code>x -&gt; 'abc'</code> and returns <code>None</code>. On the return path, <code>g</code> returns <code>4</code> (for <code>x</code>) and in the global scope, this value is assigned to <code>z</code>.

<p>Decomposition and abstraction are powerful together:
<ul>
<li>Code can be used many times but only has to be debugged once!</li>
</ul>
