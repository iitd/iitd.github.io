<h3>Files</h3>

Getting data into programs:
<ul>
<li> Put it directly into the program:
<ul>
<li> Define constants holding your values.
</ul>
</li>
<li> Get it from the user:
<ul>
<li> Keyboard input, Mouse location, etc.  Recall the <code>input()</code> function.</li>
</ul>
</li>
<li> Generate it randomly.  Use Python's <code>random</code> module.</li>
<li> Get it from an external source
<ul>
<li> Store it in a file and read it later.</li>
</ul>
</li>
</ul>

<p>Reading files
<ul>
<li> Virtually all programs that you have used at some point read files from disk:
<ul>
<li> Word processing (documents)</li>
<li> Web browser (cookies)</li>
<li> Games (saved progress)</li>
<li> Music player (songs)</li>
</ul>
</li>
</ul>

<p>The structure of files
<ul>
<li> A file is just a series of <em>bytes</em> (8 bits, where a bit is either a 0 or 1)</li>
<li> Those bytes can have a structure:
<ul>
<li> <b>Plain-text: bytes represent characters</b>.  We will focus on this.  A Python file <code>a.py</code> is also a plain-text file.</li>
<li> JPEG: bytes encode information about the structure of an image</li>
<li> MP3: bytes encode frequency information about music</li>
<li> Executable: bytes encode code and associated data (e.g., python3 executable)</li>
<li> ...</li>
</ul>
</li>
</ul>

<p>Step 1: Open the file.  Step 2: Read the file one line at a time.
<pre>
file = open("mydata.txt")
for line in file:
  print(line)
</pre>
Show an example (perhaps on Python tutor) of a file that has multiple lines and how this program reads the file one line at a time.  Notice that the last character of a line is the "\n" character.

<p>You can use the <code>strip</code> function to remove any leading and trailing whitespace (including newline and tab characters) from the string (to return a new string):
<pre>
file = open("mydata.txt")
for line in file:
  print(line.strip())
</pre>

<p>Does the following code read (and print) a file twice?
<pre>
file = open("mydata.txt")
for line in file:
  print(line)
print("------")
file = open("mydata.txt")
for line in file:
  print(line)
</pre>
No!  Internally, the <code>file</code> object maintains the current position that gets incremented for every line read from it.


<p>Example: lab7 problem 1
<pre>
def num_ways(R, G, B):
    # R, G and B are inputs to the function
    # R denotes the number of red balls
    # G denotes the number of green balls
    # B denotes the number of blue balls
    
    # Write your code below to return the number of ways to
    # arrange R red balls, G green balls and B blue balls
    # in a line such that no two consecutive balls have the
    # same color.
    return -1
    

def solution(inp):
    return num_ways(*inp)

def process_input(filename):
    lines = open(filename, 'r').readlines()
    lines = [line.strip() for line in lines]
    pos = 0
    num_tests = int(lines[0])
    input_tests = []
    for t in range(num_tests):
        pos += 1
        inp = [int(x) for x in lines[pos].split()]
        input_tests += [inp]
    return input_tests

if __name__ == "__main__":
    Input = process_input('p1_input.txt')
    for inp in Input:
        print(solution(inp))
</pre>

<h3>Directories</h3>


<h3>Let's write some programs</h3>
<p>Exercise: write a recursive function <code>reverseLines</code> that accepts a file input stream and prints the lines of that file in reverse order.
<br>Example input:
<pre>
Hello world
Hello foo
Hello bar
baz hello
</pre>
Expected output:
<pre>
baz hello
Hello bar
Hello foo
Hello world
</pre>
Is this problem self-similar? What is a file that is very easy to reverse? Hint: reversing the lines of a file can be done by (1) reading a line L from the file, (2) printing the rest of the lines in reverse order --- self-similarity, (3) printing the line L.
<pre>
void reverseLines(ifstream& input) { 
    string line; 
    if (getline(input, line)) { 
        // recursive case 
        reverseLines(input); 
        cout << line << endl; 
    } 
} 
</pre>
Where is the base-case?

<p>Exercise: write a function <code>crawl</code> that accepts a file name as a parameter and prints information about that file.
<ul>
<li>If the name represents a normal file, just print its name</li>
<li>If the name represents a directory, print its name and information about every file/directory inside it, indented.</li>
</ul>
Example:
<pre>
courses
    col100
        lab2
            hello_world.cpp
            order_of_evaluation.cpp
        lab3
            if_then_else.cpp
        minor1.pdf
        minor2.pdf
    eel200
        ...
</pre>

<p>Assume following functions are available (using SPL's "filelib.h"):
<table style="width:100%" border="1">
<tr>
<td><code>isDirectory("name")</code></td>
<td>Returns whether the filename represents a directory. Can use <code>stat()</code> method in standard C library but with more complicated syntax and semantics.</td>
</tr>
<tr>
<td><code>listDirectory("name")</code></td>
<td>returns a Vector&lt;string&gt; with the names of all files contained in the given directory. Can use a combination of <code>opendir/readdir/closedir</code> operations available in standard C library but with more complicated syntax and semantics.</td>
</tr>
</table>

<p>How is this problem self-similar? Crawling a directory can be expressed in terms of crawling the subdirectories, albeit with a different indentation.
<br>Base-case? File
<pre>
// Prints information about this file, 
// and (if it is a directory) any files inside it. 
void crawl(string filename, string indent) { 
    cout << indent << getTail(filename) << endl; 
    if (isDirectory(filename)) { 
        // recursive case; print contained files/dirs 
        Vector&lt;string&gt; filelist; 
        listDirectory(filename, filelist); 
        for (string subfile : filelist) { 
            crawl(filename + "/" + subfile, 
                  indent + "    "); 
        } 
    } 
} 
</pre>


