Have seen variable types like <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>.  Today, we will introduce <em>compound data types</em>:
<ul>
<li>Tuples</li>
<li>Lists</li>
<li>Idea of aliasing</li>
<li>Idea of mutability</li>
<li>Idea of cloning</li>
</ul>

<h3>Tuples</h3>
<ul>
<li>an ordered sequence of elements, can mix element types</li>
<li>cannot change element values, <em>immutable</em> (just like strings)</li>
<li>represented with parentheses
<pre>
te = ()  #empty tuple
t = (2, "hello", 3)
t[0] #evaluates to 2
(2, "hello", 3) + (4, 5) # evaluates to (2, "hello", 3, 4, 5)
t[1:2] #slice tuple, evaluates to ("hello",); notice the extra comma which indicates a tuple with one element
t[1:3] #slice tuple, evaluates to ("hello", 3)
len(t) #evaluates to 3
t[1] = 4 #gives error, cannot modify object
</pre>
</li>
</ul>

<p>When a tuple is used on the left-hand side (LHS) of an assignment, then it
can be used to assign to multiple variables simultaneously.  For example, this
can be conveniently used to <em>swap</em> variable values.
<br>First try:
<pre>
x = y
y = x
#This is an incorrect way to swap two variables
</pre>
<br>Second try:
<pre>
temp = x
x = y
y = temp
#Correct way to swap two variables, but this can be written in a shorter way
</pre>
<br>Best way to swap two variables (this way uses tuples both on the LHS and RHS of an assignment):
<pre>
(x, y) = (y, x)
</pre>

<p>A tuple can be used to <em>return more than one value</em> from a function
<pre>
def quotient_and_remainder(x, y):
  q = x // y   #integer division
  r = x % y
  return (q, r)

(quot, rem) = quotient_and_remainder(43, 5)
</pre>

<p><b>Manipulating tuples</b>
Let <code>aTuple</code> be a tuple of tuples, such that the inner tuples are all
of type <code>(int,string)</code>.
<pre>
def get_data(aTuple):
  nums = ()    # empty tuple
  words = ()
  for t in aTuple:
    nums = nums + (t[0],) #singleton tuple
    if t[1] not in words:
      words = words + (t[1],)  #singleton tuple
  min_n = min(nums)
  max_n = max(nums)
  unique_words = len(words)
  return (min_n, max_n, unique_words)
</pre>
The <code>get_data</code> function identifies the minimum and the maximum
numbers in the constituent tuples, and also the number of unique words (strings)
in the constituent tuples.

<h3>Lists</h3>
<ul>
<li> <em>ordered sequence</em> of information, accessible by index</li>
<li> a list is denoted by <em>square brackets</em>, <code>[]</code></li>
<li>a list contains <em>elements</em>
<ul>
<li> usually homogeneous (e.g., all integers)</li>
<li> can contain mixed types (not common)</li>
</ul>
</li>
<li>list elements can be changed so a list is <em>mutable</em>!
</ul>

<p><b>Indices and ordering</b>
<pre>
a_list = []
L = [2, 'a', 4, [1,2]]
len(L) evaluates to 4
L[0] evaluates to 2
L[2]+1 evaluates to 5
L[3] evaluates to [1,2], another list!
L[4] gives an error
i = 2
L[i-1] evaluates to 'a' because L[1]='a'
</pre>

<p><b>Lists are mutable</b>
<ul>
<li>lists are <em>mutable</em>, i.e., you can change individual elements of the same object over time!</li>
<li>assigning to an element at an index changes the value
<pre>
L = [2, 1, 3]
L[1] = 5
</pre>
After this, the list <code>L</code> is <code>[2, 5, 3]</code>.  Note that this is the <em>same object</em>!  Thus, if before the assignment we had <code>L -&gt; [2,1,3]</code>, then after the assignment we have <code>L -&gt; [2,5,3]</code> (the object remains the same, i.e., it does not get copied, rather it is updated in its place).
</li>
</ul>

<p><b>Iterating over a list</b>
<ul>
<li> compute the <em>sum of elements</em> of a list</li>
<li> common pattern, iterate over list elements
<br> One way:
<pre>
total = 0
for i in range(len(L)):
  total += L[i]
print total
</pre>
<br> More succinct way:
<pre>
total = 0
for i in L:
  total += i
print total
</pre>
Like strings, can iterate over list elements directly.
</li>
<li>Notice: list elements are indexed <code>0</code> to <code>len(L)-1</code>.
</ul>

<p><b>Operations on Lists - Add</b>
<ul>
<li> <em>add</em> elements to end of list with <code>L.append(element)</code></li>
<li> <em>mutates</em> the list!
<pre>
L = [2,1,3]
L.append(5)  #L is now [2,1,3,5]
</pre>
What is the "." (dot) in <code>L.append(5)</code>?
<ul>
<li>lists are Python objects, evertying in Python is an object</li>
<li>objects have data</li>
<li>objects have methods and functions</li>
<li>access this information by <code>object_name.do_something()</code></li>
<li>will learn more about these later</li>
</ul>
</li>
<li>to combine lists together, use <em>concatenation</em>, + operator (or <code>extend</code> method) to give you a new list
<pre>
L1 = [2,1,3]
L2 = [4,5,6]
L3 = L1 + L2   #L3 is [1,2,3,4,5,6]; L1,L2 unchanged
</pre>
<li> <em>mutate</em> list with <code>L.extend(some_list)</code>. This is different from the + operator.
<pre>
L1 = [2,1,3]
L2 = [4,5,6]
L1.extend([0,6])   #mutated L1 to [2,1,3,0,6]
</pre>
</li>
</ul>

<p><b>Operations on Lists - Remove</b>
<ul>
<li> delete element at a <em>specific index</em> with <code>del(L[index])</code>.</li>
<li> remove element at <em>end of list</em> with <code>L.pop()</code>, returns the removed element.</li>
<li>remove a <em>specific element</em> with <code>L.remove(element)</code>
<ul>
<li>looks for the element and removes it</li>
<li>if element occurs multiple times, removes first occurrence</li>
<li>if element not in list, gives an error
<pre>
L = [2,1,3,6,3,7,0] # do below in order
L.remove(2)  #mutates L to [1,3,6,3,7,0]
L.remove(3)  #mutates L to [1,6,3,7,0]
del(L[1])    #mutates L to [1,3,7,0]
L.pop()      #returns 0 and mutates L to [1,3,7]
</li>
</ul>
</ul>

<p><b>Convert lists to strings and back</b>
<ul>
<li> convert <em>string to list</em> with <code>list(s)</code>, returns a list
with every character from <code>s</code> an element in <code>L</code>.</li>
<li> can use <code>s.split()</code> to a <em>split a string on a character</em> parameter, splits on spaces if called without a parameter.</li>
<li> use <code>''.join(L)</code> to turn a <em>list of characters into a
string</em>, can give a character in quotes to add char between every element.</li>
</ul>
<pre>
s = "I&lt;3 cs"  #s is a string
list(s)   #returns ['I','&lt;','3',' ','c','s']
s.split('&lt;')  #returns ['I', '3 cs']
L = ['a','b','c']  # <code>L</code> is a list
''.join(L)    #returns "abc"
'_'.join(L)   #returns "a_b_c"
</pre>

<p><b>Other list operations</b>
<ul>
<li> <code>sort()</code> and <code>sorted()</code></li>
<li> <code>reverse()</code></li>
<li> and many more, see <a href=https://docs.python.org/3/tutorial/datastructures.html>https://docs.python.org/3/tutorial/datastructures.html</a>.
</ul>
<pre>
L = [9,6,0,3]
sorted(L)   # returns sorted list, does not mutate L
L.sort()    # mutates L to [0,3,6,9]
L.reverse() # mutates L to [9,6,3,0]
</pre>
