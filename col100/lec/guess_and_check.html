<h3>Approximate solutions</h3>
What if we are interested in approximate solutions for numbers that are not
perfect cubes?
<ul>
<li> <em>good enough</em> solution </li>
<li> start with a guess and increment by some <em>small value</em> </li>
<li> keep guessing until <code>|guess<sup>3</sup>-cube| &gt;= epsilon</code>
for some <em>small epsilon</em> </li>
</ul>

<p>
<pre>
cube = int(input("Enter a number: ")
epsilon = 0.01
guess = 0.0
increment = 0.0001
num_guesses = 0
while abs(guess**3 - cube) &gt;= epsilon and guess &lt;= cube:
  guess += increment
  num_guesses += 1
if abs(guess**3 - cube) &gt;= epsilon:
  print('Failed on cube root of', cube)
else:
  print(guess, 'is close to the cube root of', cube)
</pre>
Problem:
<ul>
<li> decreasing increment size -&gt; slower program
<li> increasing epsilon -&gt; less accurate answer
</ul>

<h3>Bisection Search</h3>
<ul>
<li> half interval each iteration</li>
<li> new guess is halfway in between</li>
<li> Play a game to illustrate this</li>
</ul>

<p>Finding the cube root through a bisection search
<pre>
cube = int(input("Enter a number: ")
epsilon = 0.01
low = 0
high = cube
guess = (low+high)/2.0
num_guesses = 0
while abs(guess**3 - cube) &gt;= epsilon:
  if guess**3 &lt; cube:
    low = guess
  else:
    high = guess
  guess = (high + low)/2.0
  num_guesses += 1
print 'num_guesses =', num_guesses
print(guess, 'is close to the cube root of', cube)
</pre>

<p>Convergence of Bisection Search
<ul>
<li>Search space (using <code>N=(cube+1)*epsilon</code>)
<ul>
<li>first guess:  <code>N/2</code></li>
<li>second guess:  <code>N/4</code></li>
<li>k<sup>th</sup> guess:  <code>N/2<sup>k</sup></code></li>
</ul>
<li>guess converges on the order of <code>log<sub>2</sub>N</code> steps</li>
<li>bisection search works when value of function varies monotonically with input</li>
<li>code as shown only works for positive cubes &gt; 1 -- why?</li>
<li>challenges:
<ul>
<li>modify to work with negative cubes!
<ul>
<li>Use the <code>abs()</code> function.</li>
</ul>
</li>
<li>modify to work with cube&lt;1!</li>
<ul>
<li>For <code>cube&lt;1</code>, search space is <code>0</code> to <code>x</code>, but cube root is greater than <code>cube</code> and less than <code>1</code>.</li>
<li>Modify the code to choose the search space depending on value of <code>cube</code>.</li>
</ul>
</ul>
</ul>

<h3>Functions</h3>
<ul>
<li>More code is not necessarily a good thing</li>
<li>Measure good programmers by the amount of functionality
<ul>
<li> Introduce <em>functions</em></li>
<li> Mechanism to achieve <em>decomposition</em> and <em>abstraction</em></li>
</ul>
</li>
</ul>

<p>Example: Pen
<ul>
<li> A pen is a black-box</li>
<li> We don't need to know how it works</li>
<li> Know the interface: click before use, press against paper to release ink</li>
<li> <b>Abstraction</b>: do not need to know how pen works to use it.</li>
<li> Different components in the pen are manufactured by different entities.  The assembler simply assembles the components to produce something useful.</li>
<li> <b>Decomposition</b>: different components work together to achieve an end goal.</li>
</ul>

<p>In programming, create structure with <em>decomposition</em>
<ul>
<li> Divide code into <em>modules</em>:
<ul>
<li> Modules are self contained </li>
<li> used to break-up code </li>
<li> intended to be reusable </li>
<li> keep code organized </li>
<li> keep code coherent </li>
</ul>
In this lecture, we achieve decomposition with <em>functions</em>. Later, we achieve
decomposition with <em>classes</em>.
</ul>

<p><b>Functions</b> are reusable pieces/chunks of code.  Functions are not run in a program until they are <em>called</em> or <em>invoked</em> in a program. Function characteristics:
<ul>
<li> has a name</li>
<li> has parameters (0 or more)</li>
<li> has a <em>docstring</em> (optional but recommended)</li>
<li> has a body</li>
<li> returns something</li>
</ul>

<p>Writing a function
<pre>
def is_odd(i):  #keyword name parameeters
  """  #docstring begin
  Input: i, a positive int
  Returns true if i is odd, otherwise False
  """  #docstring end
  #body
  print("inside is_odd")
  return i%2 == 1   #return is a keyword


is_odd(4)  #later in the code, you call the function using its name and values for parameters
</pre>


