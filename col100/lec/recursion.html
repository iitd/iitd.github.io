<h3> Reviewing Mutation and Aliasing</h3>

<p>The following code works as expected, and prints <code>[[1,4], [2,5], [3,6]]</code>
<pre>
def trans(given):
  nrows = len(given)
  ncols = len(given[0])
  matrix = [[0,0],[0,0],[0,0]]
  for i in range(ncols):
    for j in range(nrows):
      matrix[i][j] = given[j][i]
  return matrix

a = [[1,2,3],[4,5,6]]
</pre>
However, the following code prints <code>[[3,6], [3,6], [3,6]]</code>:
<pre>
def trans(given):
  nrows = len(given)
  ncols = len(given[0])
  #matrix = [[0,0],[0,0],[0,0]] #commented this out and replaced it with the line below
  matrix = [[0]*nrows]*ncols
  for i in range(ncols):
    for j in range(nrows):
      matrix[i][j] = given[j][i]
  return matrix

a = [[1,2,3],[4,5,6]]
</pre>
Why?  Because the multiplication with <code>ncols</code> simply duplicates the references to the same list.

<p>Here is the correct version:
<pre>
def trans(given):
  nrows = len(given)
  ncols = len(given[0])
  matrix = [[0 for _ in range(nrows)] for _ in range(ncols)]  #initialize as separate lists for each row
  for i in range(ncols):
    for j in range(nrows):
      matrix[i][j] = given[j][i]
  return matrix

a = [[1,2,3],[4,5,6]]
</pre>

<p>It is worth emphasizing again that there is a subtle difference between:
<ul>
<li> <code>L.append(item)</code></li>
<li> <code>L = L + [item]</code></li>
</ul>
In the first case, the original list (associated with <code>L</code>) is getting modified; while in the second case, a new list is getting created and <code>L</code> is then associated with the new list.

<h3>Recursion</h3>
What is recursion?
<ul>
<li> Algorithmically: a way to design solutions to problems by <em>divide-and-conquer</em> or <em>decrease-and-conquer</em>.
<ul>
<li> Reduce a problem to simpler versions of the same problem. </li>
</ul>
</li>
<li> Semantically: a programming technique where a <em>function calls itself</em>.
<ul>
<li> in programming, goal is to NOT have infinite recursion
<ul>
<li> must have one or more <em>base cases</em> that are easy to solve.</li>
<li> must solve the same problem on <em>some other input</em> with the goal of simplifying the larger problem input.</li>
</ul>
</ul>
</ul>

<p><b>Iterative algorithms so far</b>
<ul>
<li> <em>looping constructs</em> lead to iterative algorithms.</li>
<li> can capture computation in a state of <em>state variables</em> that update on each iteration through loop.</li>
</ul>

<p>Multiplication: Iterative Solution
<ul>
<li> "multiply a*b" is equivalent to "add a to itself b times"</li>
<li> capture <em>state</em> by
<ul>
<li> an iteration number <code>i</code> starts at <code>b</code>
<pre>
i &lt;- i-1 and stop when 0
</pre>
</li>
<li> a current <em>value of computation</em> (<code>result</code>)
<pre>
result &lt;- result + a
</pre>
</li>
</ul>
</li>
</ul>
<pre>
def mult_iter(a, b):
  result = 0
  while b &gt; 0:   #iteration
    result += a     #current value of computation: a running sum
    b -= 1          #current value of iteration variable
  return result
</pre>

<p>Multiplication: Recursive Solution
<ul>
<li> <em>recursive step</em>: think how to reduce problem to a <em>simpler or smaller version</em> of the same problem.
<pre>
a*b = a + a + ... + a     (b times)
    = a + (a + ... + a)   (b-1 times for the value in the parentheses)
    = a + a*(b-1)         (the latter term has the same structure as the original problem)
</pre>
</li>
<li> <em>base case</em>: keep reducing problem until reach a simple case that can be <em>solved directly</em> when <code>b=1, a*b=a</code>.
<pre>
def mult(a, b):
  if b == 1:         # base case
    return a
  else:
    return a + mult(a, b-1)  # recursive step
</pre>
</li>
</ul>

<p>Factorial
<pre>
n! = n*(n-1)*(n-2)*...*1
</pre>
<ul>
<li> for what <code>n</code> do we know the factorial?
<pre>
if n == 1:
  return 1  #base case
</pre>
</li>
<li>
how to reproduce the problem?  Rewrite in terms of something simpler to reach the base case
<pre>
else:
  return n*factorial(n-1)    #recursive step
</pre>
</li>
</ul>

<p>Recursive function scope example
<pre>
def fact(n):
  if n == 1:
    return 1
  else:
    return n*fact(n-1)

print(fact(4))
</pre>
<ul>
<li> Global scope has <code>fact -&gt; some code</code></li>
<li> fact scope (call with n=4) has <code>n -&gt; 4</code></li>
<li> fact scope (call with n=3) has <code>n -&gt; 3</code></li>
<li> fact scope (call with n=2) has <code>n -&gt; 2</code></li>
<li> fact scope (call with n=1) has <code>n -&gt; 1</code></li>
</ul>
Order of computation:
<ul>
<li> fact scope (call with n=1) returns <code>1</code></li>
<li> fact scope (call with n=2) returns <code>2*fact(1)=2*1=2</code></li>
<li> fact scope (call with n=3) returns <code>3*fact(2)=3*2=6</code></li>
<li> fact scope (call with n=4) returns <code>4*fact(3)=4*6=24</code></li>
<li> global scope prints <code>fact(4)=24</code></li>
</ul>

<p>Some observations:
<ul>
<li>each recursive call to a function creates its <em>own scope/environment</em>.</li>
<li><em>bindings of variables</em> in a scope are not changed by recursive call.
<ul>
<li>using the same variable names but they are different objects in separate scopes.</li>
</ul>
</li>
<li>flow of control passes back to <em>previous scope</em> once function call returns value.</li>
</ul>

<p>Iteration vs. Recursion.
<br>Iteration:
<pre>
def factorial_iter(n):
  prod = 1
  for i in range(1,n+1):
    prod *= i
  return prod
</pre>
<br>Recursion:
<pre>
def factorial(n):
  if n == 1:
    return 1
  else:
    return n*factorial(n-1)
</pre>
<ul>
<li> recursion may be simpler, more intuitive</li>
<li> recursion may be efficient from programmer's point of view</li>
<li> recursion may not be efficient from computer's point of view</li>
</ul>

<p>Inductive reasoning
<pre>
def mult_iter(a, b):
  result = 0
  while b &gt; 0:
    result += a
    b -= 1
  return result

def mult(a, b):
  if b == 1:
    return a
  else:
    return a + mult(a, b-1)
</pre>
<ul>
<li>How do we know that our recursive code will work?</li>
<li><code>mult_iter</code> terminates because <code>b</code> is initially positive, and decreases by <code>1</code> each time around loop; thus must eventually become less than <code>1</code>.</li>
<li><code>mult</code> called with <code>b=1</code> has no recursive call and stops</li>
<li><code>mult</code> called with <code>b&gt;1</code> makes a recursive call with a smaller version of <code>b</code>; must eventually reach call with <code>b=1</code>.</li>
</ul>

<p>Mathematical Induction
<ul>
<li> To prove a statement indexed on integers is true for all values of <code>n</code>:
<ul>
<li> Prove it is true when <code>n</code> is smallest value (e.g., <code>n=0</code> or <code>n=1</code>).</li>
<li> Then prove that if is true for an arbitrary value of <code>n</code>, one
can show that it must be true for <code>n+1</code>.
</ul>
</li>
</ul>

<p>Example of Induction
<ul>
<li> 0+1+2+...+n = (n(n+1))/2</li>
<li> Proof:
<ul>
<li> If <code>n=0</code>, then LHS is 0 and RHS is <code>0*1/2=0</code>, so true</li>
<li>Assume true for some <code>k</code>, then need to show that
<pre>
0+1+2+...+k+(k+1) = ((k+1)(k+2))/2
</pre>
</li>
<li>LHS is <code>k(k+1)/2 + (k+1)</code> by assumption that property holds for problem of size <code>k</code>.</li>
<li>This becomes, by algebra, <code>((k+1)(k+2))/2</code>.</li>
</ul>
</li>
<li> Hence expression holds for all <code>n &gt;= 0</code></li>
</ul>

<p>Relevance to code?
<pre>
def mult(a, b):
  if b == 1:
    return a
  else:
    return a + mult(a, b-1)
</pre>
Same logic applies:
<ul>
<li> Base case, we can show that <code>mult</code> must return correct answer</li>
<li> For recursive case, we can assume that <code>mult</code> correctly returns an answer for problems of size smaller than <code>b</code>, then by the addition step, it must also return a correct answer for problem of size <code>b</code>.</li>
<li>Thus, by induction, code correctly returns answer</li>
</ul>

<p>Towers of Hanoi.
The story
<ul>
<li> Three tall spikes</li>
<li> Stack of 64 different sized disks -- start on one spile</li>
<li> Need to move stack to second spike (at which point universe ends)</li>
<li> Can only move one disc at a time, and a larger disc can never cover
up a small disc</li>
</ul>
Show some examples of a small number of disks.
Having seen a set of examples of different sized stacks, how would you write
a program to print out the right set of moves? Think recursively:
<ul>
<li>Solve a smaller problem</li>
<li>Solve a basic problem</li>
<li>Solve a smaller problem</li>
</ul>
<pre>
def printMove(fr, to):
  print('move from ' + str(fr) + ' to ' + str(to))

def Towers(n, fr, to, spare):
  if n == 1:
    printMove(fr, to)
  else:
    Towers(n-1, fr, spare, to)
    Towers(1, fr, to, spare)
    Towers(n-1, spare, to, fr)
</pre>

<p><b>Recursion with multiple base cases</b>
<ul>
<li>Fibonacci numbers
<ul>
<li>Leonardo of Pisa (aka Fibonacci) modeled the following challenge
<ul>
<li>Newborn pair of rabbits (one female, one male) are put in a pen</li>
<li>Rabbits mate at age of one month</li>
<li>Rabbits have a one month gestation period</li>
<li>Assume rabbits never die, that female always produces one new pair (one male, one female) every month from its second month on.</li>
<li>How many female rabbits are there at the end of one year?</li>
</ul>
</li>
</ul>
</li>
</ul>
Show a graphical picture of a pair of rabbits (A), they mate after one month, and generate another pair (B) after two months.  After three months, the original pair produces another pair (C); while pair B mates. After four months, both pairs A and B, produce two pairs (D and E), while C mates.  And so on...

<p>
Let's work out the numbers:
<ul>
<li> After one month (call it 0): 1 female</li>
<li> After second month --- still one female (now pregnant)</li>
<li> After third month --- two females, one pregnant, one not</li>
<li> In general: <code>females(n) = females(n-1)+females(n-2)</code>:
<ul>
<li>Every female alive at month <code>n-2</code> will produce one female
in month <code>n</code>.</li>
<li>These can be added to those alive in month <code>n-1</code> to get total
alive in month <code>n</code>.</li>
</ul>
</li>
</ul>

<p>Fibonacci
<ul>
<li> Base cases:
<ul>
<li> females(0) = 1</li>
<li> females(1) = 1</li>
</ul>
</li>
<li> Recursive case:
<ul>
<li> females(n) = females(n-1) + females(n-2)</li>
</ul>
</li>
</ul>
<pre>
def fib(x):
  """assume x an int &gt;= 0
     returns Fibonacci of x"""
  if x == 0 or x == 1:
    return 1
  else:
    return fib(x-1) + fib(x-2)
</pre>

<h3>Recursion on Non-Numerics</h3>
<ul>
<li> how to check if a string of characters is a palindrome, i.e., reads the
same forwards and backwards
<ul>
<li> "Able was I, ere I saw Elba" --- attributed to Napoleon</li>
<li> "Are we not drawn onward, we few, drawn onward to new era? --- attributed to Anne Michaels</li>
</ul>
</li>
</ul>
Solving recursively?
<ul>
<li> First, convert the string to just characters, by stripping out punctuation, and converting upper case to lower case</li>
<li> Then
<ul>
<li> Base case: a string of length 0 or 1 is a palindrome</li>
<li> Recursive case:
<ul>
<li>If first character matches last character, then is a palindrome if middle section is a palindrome</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>Example
<ul>
<li> "Able	was	I,	ere	I	saw	Elba"	--&gt; "ablewasiereisawelba"</li>
<li> <code>isPalindrome("ablewasiereisawleba")</code> is same as:
<ul>
<li> <code>"a" == "a"</code> and <code>isPalindrome("blewasiereisawelb")</code>.</li>
</ul>
</ul>
<pre>
def isPalindrome(s):
  def toChars(s):
    s = s.lower()
    ans = ''
    for c in s:
      if c in 'abcdefghijklmnopqrstuvwxyz':
        ans = ans + c
    return ans

  def isPal(s):
    if len(s) &lt;= 1:
      return True
    else:
      return s[0] == s[-1] and isPal(s[1:-1])

  return isPal(toChars(s))
</pre>
This is an example of a <em>divide and conquer</em> algorithm.
<ul>
<li> Solve a hard problem by breaking it into a set of subproblems such that:
<ul>
<li> subproblems are easier to solve than the original</li>
<li> solutions of the subproblems can be combined to solve the original</li>
</ul>
</li>
</ul>
