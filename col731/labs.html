<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>COL731: Advanced Compiler Techniques</title>
</head><body><h1><font color="blue">COL731: Advanced Compiler Techniques</font></h1>

<h2><i>Lab 1 : Experiment with LLVM's SLPVectorizer</i></h2>
<p><em>Due date: 20th August 2023, 11:59pm IST</em>

<p>5 marks total</p>

<p>
<ol>
<li> Clone the LLVM Repository at <a href=https://github.com/llvm/llvm-project>https://github.com/llvm/llvm-project</a>.</li>
<li> Study and experiment with the SLPVectorizer at path <code>llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp</code>.</li>
<li> Create a report on your experiments that must contain at least the following information:
<ul>
<li> What is the algorithm of LLVM's SLP Vectorizer, and how does it differ from the SLP paper that we studied in class? Show the pseudo-code of LLVM's SLP vectorizer, similar to how it is shown in the SLP paper.</li>
<li> What are the LLVM analysis passes that the SLP Vectorizer depends upon?</li>
<li> What are the functions defined in the CPP file and what is the brief summary of what each function does?</li>
<li> Compile an example vectorizable program using <code>clang12 -O3 -mllvm -print-after-all -mllvm -print-before-all -c example.c</code>.  Compare the input/output of the SLP vectorizer pass, and discuss the transformations in your report.
<ul>
<li>Choose your example vectorizable program carefully, so that the discussion becomes more interesting.</li>
<li>Identify at least one analysis or transformation pass (on which the SLP vectorizer depends) such that if you disable that pass, the SLP vectorization becomes less effective (or ineffective) on your example program.  Explain why this happens.
</ul>
</ul>
</li>
</ol>
<em>Submission</em>: Email a PDF copy of your report to the instructor. The PDF filename should contain your entry-number and name. For example if your entry number is 2121CS1000 and your name is ABC, then  your filename should be 2121CS1000_ABC.pdf

<h2><i>Lab 2 : GEMM</i></h2>
<p><em>Due date: 24th September 2023, 11:59pm IST</em>

<p>5 marks total</p>
<p>
We have already studied about dependence analysis and loop transformations in class. In
this assignment, we will look at the potential of loop optimization through the polyhedral
model. Compilation using polyhedral model involves representation of programs
(especially those involving nested loops and arrays) to parametric polyhedra and
exploiting combinatorial and geometrical optimizations on these objects to analyze and
optimize the programs. The interest of using polyhedral representations is that they can be
manipulated or optimized with algorithms whose complexity depends on their structure
and not on the number of elements they represent. Furthermore, generic and compact
solutions can be designed that depend on program parameters (e.g., loop bounds, tile sizes,
array bounds).

<p>We will use <em>Polly</em>, a high-level loop and data-locality optimizer for LLVM IR for performing
experiments in this assignment. There exists other tools, like Graphite (for GCC)
and PLUTO, which also support polyhedral compilation.

<ol>
<li> Clone the Polybench/C benchmark at <code>https://github.com/MatthiasJReisinger/PolyBenchC-4.2.1</code> and look at the the General matrix-matrix multiplication (GEMM) benchmark at <code>linear-algebra/blas/gemm</code> (<a href=https://github.com/MatthiasJReisinger/PolyBenchC-4.2.1/tree/master/linear-algebra/blas/gemm>direct link</a>.
<li> Use the following flags to compile GEMM:
<ul>
<li> -DPOLYBENCH_TIME</li>
<li> -DEXTRALARGE_DATASET</li>
<li> -DDATA_TYPE_IS_INT</li>
</ul>
<li> 
Study the Polly optimization framework and how gemm is optimized using it.
Note that, polly is not enabled by default in Clang/LLVM to automatically optimize C/C++ code
during compilation. It needs to be enabled by passing explicit flags. Please refer the below
mentioned documents for further details.
<ul>
<li><a href=https://media.readthedocs.org/pdf/polly-/latest/polly-.pdf>Polly documentation</a></li>
<li><a href=https://polly.llvm.org/publications/grosser-diploma-thesis.pdf>Tobias Grosser's Diploma Thesis on Enabling Polyhedral Optimizations in LLVM</a></li>
<li><a href=https://polly.llvm.org/>Polly webpage</a></li>
</ul>
</li>
<li>Report the run times for gemm.c, when compiled with
<ul>
<li> GCC (-O3)</li>
<li> ICC (-O3)</li>
<li> Clang (-O3) without polly extension</li>
<li> Clang (-O3) with polly extension</li>
</ul>
</li>
<li>
Analyze the x86 assembly code generated in each of the above four cases.
Write (if possible) a faster x86 implementation using intrinsics or inline assembly than the
above code generated by Clang (with Polly) for the GEMM program. You can use any of the supported
instruction set extensions for your manual optimization (SSE, FMA, AVX).
Report the assembly generated in all four cases, your analysis for these assembly codes,
your manually optimized source code and x86 assembly. Report the run times for your
implementation. We provide some relevant references below:
<ul>
<li> <a href=https://software.intel.com/sites/landingpage/IntrinsicsGuide/>Intel Intrinsics Guide</a></li>
<li> <a href=https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>Extended Asm - Assembler Instructions with C Expression Operands</a></li>
</ul>
</li>
</ol>
<em>Submission</em>: Email a PDF copy of your report to the instructor. The PDF filename should contain your entry-number and name. For example if your entry number is 2121CS1000 and your name is ABC, then  your filename should be 2121CS1000_ABC.pdf

<h2><i>Lab 3 : Experiment with LLVM's Polly</i></h2>
<p><em>Due date: 26th October 2023, 11:59pm IST</em>

<p>5 marks total</p>

<p>
<ol>
<li> Through experiments on compiling small hand-written C programs (written by you), identify the strengths and limitations
of the Polly framework.  Report your findings (along with the hand-written C programs that you used).
</li>
<li> In particular, identify the algorithm used in Polly to eliminate the predicates (guards) on individual statements through partitioning.  For example, consider a case where we are partitioning an inner loop, whose statement bounds (for each statement) are 1-D intervals where the lower and upper bounds are given by affine expressions of the surrounding loop indices.  Write example programs where:
<ol>
<li> The lower and upper bounds of each interval are statically identifiable during partitioning (after the space partitioning algorithm has identified a schedule and empty iterations have been eliminated).</li>
<li> The lower and upper bounds of each interval are not statically identifiable (after the space partitioning algorithm has identified a schedule and empty iterations have been eliminated).</li>
</ol>
For each example, report what method is used by the Polly framework to identify the lower/upper bounds of each partition. Do they resort to runtime generation of partition bounds (to eliminate guards) or do they simply leave the guards in (to avoid the overhead of identifying partition bounds at runtime).
</ol>
<em>Submission</em>: Email a PDF copy of your report to the instructor. The PDF filename should contain your entry-number and name. For example if your entry number is 2121CS1000 and your name is ABC, then  your filename should be 2121CS1000_ABC.pdf

<h2><i>Lab 4 : Experiment with the Equivalence Checker</i></h2>
<p><em>Due date: 19th November 2023, 11:59pm IST</em>

<ul>
<li>Experiment with <a href=https://alive2.llvm.org/ce/>Alive2</a>. Show:
<ol>
<li>One example where Alive correctly validates a peephole optimization</li>
<li>One example where Alive incorrectly validates a peephole optimization</li>
<li>One example where Alive fails to validate a peephole optimization. Ideally it should be manually hard to see that this peephole optimization is incorrect.</li>
</ol>
<li>Experiment with CompCert
<ul>
<li>Download and install the <a href=https://compcert.org/>CompCert compiler</a>
<ul>
<li> <code>sudo apt install opam</code></li>
<li> <code>opam install menhir menhirLib coq</code></li>
<!--See this <a href=https://stackoverflow.com/questions/66690897/trouble-installing-compcert-c-compiler-on-ubuntu#:~:text=Error%3A%20cannot%20determine%20the%20location,the%20OPAM%20package%20for%20Menhir.>Stack overflow page</a> for some troubleshooting tips.</li>-->
<li> <code>./configure x86_32-linux</code>
<li> <code>make all</code>
</ul>
</li>
<li>Using some compute-intensive programs, compare the performance of CompCert-generated executables with the optimized executables generated by a production compiler like LLVM/Clang and GCC.</li>
<li>CompCert is a certified compiler written in the Coq proof assistant.  See if you can understand the high-level proof statement of CompCert.  Follow the steps below.
<ul>
<li> Read <a href=https://compcert.org/man/manual.pdf>Section 1.2 of the CompCert manual</a> to understand the ``Semantic Preservation Theorem''.</li>
<li> Read <code>Theorem trans_program_correct</code> in file <code>backend/Constpropproof.v</code>.  See if you can explain this theorem informally by taking a look at the following:
<ul>
<li> Take a look at <code>Definition transf_prog</code> in file <code>backend/Constprop.v</code> </li>
<li> Take a look at <code>Lemma transf_program_match</code> in file <code>backend/Constpropproof.v</code> </li>
</ul>
The full proof specification is relatively deep.  For full credit in this part of the question, it would suffice if you only provide an informal explanation of what is happening till a shallow depth e.g., you can just stop at <code>Definition match_prog</code> in <code>backend/Constpropproof.v</code> (by explaining informally what you think it is proving).  However, you are welcome to delve deeper if you prefer (you will not be penalized for not delving deeper).
</li>
<li> 
</ul>
</li>
</ul>
</ul>

</ul>
