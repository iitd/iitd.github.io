<ol>
<li><b>Understanding the file &#34;x86/except.cc&#34;</b>
Here is a brief description of the except.cc file. 

<strong>Lines 609 to 703</strong> define the IDT of HOH.
 Here each call to idt_set ( interrupt_no , handler ) creates an entry in the IDT. These handlers cannot be directly searched as they get created through expansion of macros. 

 <strong>Classification of interrupts: </strong>
 To ease the task of writing interrupt handlers ( by automatically generating them ) , we classify all the interrupts into 6 categories :
 <ol>
   <li>isr_critical</li>
   <li>isr_user</li>
   <li>isr_pic_master</li>
   <li>isr_pic_slave</li>
   <li>isr_lapic</li>
   <li>isr_lapic_internal</li>
 </ol>


 Each of the above are macros and used at <strong>lines 147 - 246</strong> to define the actual handlers for each IDT entry. 
 Each of the categories will jump to their respective handlers which are defined using _handler macro in the <strong>lines 291 - 296.</strong>
 <ol>
   <li>handler_critical</li>
   <li>handler_user</li>
   <li>handler_pic_master</li>
   <li>handler_pic_slave</li>
   <li>handler_lapic</li>
   <li>handler_lapic_internal</li>
 </ol>
 Here each handler checks for user mode/ kernel mode. If it is user mode, it calls the user mode handler. 
 It also checks if the esp lies withing a certain range and depending upon that calls kmf_ or kff_ handler. ( Questions to ponder : Why does it do that ? Why do we need different handlers depending on position of stack top ? ) 

 So, for next level of indirection we have total <strong>3 {kmf, kff, user } X 6 {categories } = 18 different paths.</strong>
 <strong></strong>
 These 18 different labels are generated by the macros ( ring0_cfunc, ring3_cfunc , ring0_setflag , ring0_preempt ) from <strong>lines 453 - 475.</strong>
 Finally the functions actually handling the interrupts are defined from <strong>lines 517 - 607.</strong>


Further understanding of how macros are expanded are as follows:

The local APIC decrements the current count until it reaches zero, then generates a timer IRQ.
The reset() method of the device handler in turn calls lapic_internal_reset.
'<strong>lapic_internal_base+0x6</strong>' is the interrupt number that is generated when timer count become zero.

<pre>devices/lapic.h: 
   void reset(): 
     lapic_internal_reset():

     reset_timer(lapic_internal_base+lapic_internal_timer, false  , false, 0, xapic_by1); //1000000000UL

</pre>

Interrupt handler for this function is defined as follows:
<strong>isr_lapic_handler</strong> is the interrupt handler function for interrupt 'lapic_internal_base+0x6'

<pre>x86/except.cc: 
  idt_set(lapic_internal_base+0x6, isr_lapic_internal6);

</pre>

isr_lapic_internal6 definition is expanded as follows:

<pre>//
//  Macro for Class 4b ISRs
//
#define _isr_lapic_internal(_n)                   \              // _n = 6                                          // _n = 6
         __isr      void isr_lapic_internal##_n();\              __isr      void isr_lapic_internal6();             __isr      void isr_lapic_internal6();
         __asm(                                   \              __asm(                                             __asm(
         "  .text                            \n\t"\              "  .text                            \n\t"          "  .text                            \n\t"
         "  .global isr_lapic_internal" STR(_n) " \n\t"\         "  .global isr_lapic_internal" "6"  " \n\t"        "  .global isr_lapic_internal6        \n\t"
         "  isr_lapic_internal" STR(_n) ":   \n\t"\              "  isr_lapic_internal" "6" ":   \n\t"              "  isr_lapic_internal6:               \n\t"
         "   pushl $0                        \n\t"\              "   pushl $0                        \n\t"          "   pushl $0                        \n\t"
         "   pushl $" STR(_n) "              \n\t"\              "   pushl $" "6" "              \n\t"              "   pushl $6                    \n\t"
         "   jmp handler_lapic_internal      \n\t"\              "   jmp handler_lapic_internal      \n\t"          "   jmp handler_lapic_internal      \n\t"
         )                                        \              )                                                  )
</pre>

This method jumps to method <strong>handler_lapic_internal</strong>
 
isr_lapic_internal6 definition is expanded as follows:
<pre>//_name = handler_lapic_internal //_kmf  = kmf_lapic_internal //_kff  = kff_lapic_internal //_uf   = uf_lapic_internal
#  define  _handler(_name,_kmf,_kff,_uf)          \                             
         __asm(                                   \                                      __asm(                                   
         "  .text                            \n\t"\                                      "  .text                            \n\t"
         " " STR(_name) ":                   \n\t"\                                      " handler_lapic_internal:           \n\t"
         "  cli                              \n\t"\                                      "  cli                              \n\t"
         "  testb $3, 12(%esp)               \n\t"\                                      "  testb $3, 12(%esp)               \n\t"
         "  jz 1f                            \n\t"\                                      "  jz 1f                            \n\t"
         "  pushl %eax                       \n\t"\                                      "  pushl %eax                       \n\t"
         "  movw $16, %ax                    \n\t"\                                      "  movw $16, %ax                    \n\t"
         "  movw %ax, %ds                    \n\t"\                                      "  movw %ax, %ds                    \n\t"
         "  movw %ax, %es                    \n\t"\                                      "  movw %ax, %es                    \n\t"
         "  movw $48, %ax                    \n\t"\                                      "  movw $48, %ax                    \n\t"
         "  movw %ax, %fs                    \n\t"\                                      "  movw %ax, %fs                    \n\t"
         "  movw %ax, %gs                    \n\t"\                                      "  movw %ax, %gs                    \n\t"
         "  popl %eax                        \n\t"\                                      "  popl %eax                        \n\t"
         "  jmp    " STR(_uf) "              \n\t"\                                      "  jmp    uf_lapic_internal         \n\t"
         "1:                                 \n\t"\                                      "1:                                 \n\t"
         "  cmp %gs:" STR(core_offset_stackend) ", %esp\n\t"\                            "  cmp %gs:20 , %esp                \n\t"
         "  ja     " STR(_kff) "             \n\t"\                                      "  ja  kff_lapic_internal           \n\t"
         "  cmp %gs:" STR(core_offset_stackbegin) ", %esp\n\t"\                          "  cmp %gs:12, %esp\n\t"
         "  jbe    " STR(_kff) "             \n\t"\                                      "  jbe kff_lapic_internal        \n\t"
         "  jmp    " STR(_kmf) "             \n\t"\                                      "  jmp  kmf_lapic_internal          \n\t"
         )                                        \                                      )</pre>

12(esp) is CS pushed by interrupt handler
And $3 with CS to check the ring level
if it is non zero, then it is ring3. jmp to uf_lapic_internal
else it is ring0.
check esp. if it is between main_stackbegin and main_stackend, then goto kmf_lapic_internal (m stands for main_stack)
else it's a fiber stack, so goto kff_lapic_internal (f stands for fiber_stack)


We need to know about these three functions:
- kmf_lapic_internal
- kff_lapic_internal
- uf_lapic_internal


Let's look at kff_lapic_internal:

It's gets defined by the macro we are supposed to write: labs/preempt.h

_ring0_preempt(kff_lapic_internal, c_lapic_internal);


Let's expand given code:


// _name : kff_lapic_internal
// _f    : c_lapic_internal

<pre>#  define  _ring0_preempt(_name,_f)            \           
  __asm(                                       \             __asm(                                       \
      "  .text                            \n\t"\                 "  .text                            \n\t"\
      " " STR(_name) ":                   \n\t"\                 "  kff_lapic_internal:               \n\t"\
      "  pushl %edx                       \n\t"\                 "  pushl %edx                       \n\t"\
      "  pushl %ecx                       \n\t"\                 "  pushl %ecx                       \n\t"\
      "  pushl %eax                       \n\t"\                 "  pushl %eax                       \n\t"\
      "  call " STR(_f) "                 \n\t"\                 "  call c_lapic_internal            \n\t"\
      "  popl  %eax                       \n\t"\                 "  popl  %eax                       \n\t"\
      "  popl  %ecx                       \n\t"\                 "  popl  %ecx                       \n\t"\
      "  popl  %edx                       \n\t"\                 "  popl  %edx                       \n\t"\
      "                                   \n\t"\                 "                                   \n\t"\
      "  # insert your code here          \n\t"\                 "  # insert your code here          \n\t"\
      "                                   \n\t"\                 "                                   \n\t"\
      "                                   \n\t"\                 "                                   \n\t"\
      "  jmp iret_toring0                 \n\t"\                 "  jmp iret_toring0                 \n\t"\
      )                                        \                 )                                        \
</pre>

c_lapic_internal will call lapic_eoi

Now we need to look at iret_toring0

<pre>__asm(
    "  .text                            \n\t"
    " iret_toring0:                     \n\t"
    "  addl $8,%esp                     \n\t"
    "  iretl                            \n\t"
    );
</pre>
</li>
</ol>
