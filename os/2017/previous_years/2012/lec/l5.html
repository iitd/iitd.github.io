<html>
<head><title>Lecture 6: System calls &amp; Interrupts &amp; Exceptions</title></head>
<body>

<h1>Interrupts &amp; Exceptions</h1>

<p>
Required reading: xv6
<code>trapasm.S</code>,
<code>trap.c</code>,
<code>syscall.c</code>,
<code>initcode.S</code>,
<code>usys.S</code>.
Skim
<code>vectors.S</code>,
<code>lapic.c</code>,
<code>ioapic.c</code>,
<code>picirq.c</code>.
<br>
You will need to consult
<a href="../readings/ia32/IA32-3A.pdf">IA32 System
Programming Guide</a> chapter 5 (skip 5.7.1, 5.8.2, 5.12.2).

<h2>Introduction</h2>

<pre>
  last week we transferred from kernel to user
  today: how to get from user to kernel
  three reasons for transitions:
    system calls
    program faults (div by zero, page fault)
    external device interrupts
  why do we need to take special care for user -> kernel?
    security/isolation
    only kernel can touch devices, MMU, FS, other process' state, &c
    think of user program as a potential malicious adversary
  what has to happen?
    save user state for future transparent resume
    set up for execution in kernel (stack, segments)
    choose a place to execute in kernel
    get at system call arguments
    do it all securely
  it's neat that interrupts, faults, system call use same mechanism!
</pre>

<!--
(Handout: from Intel Volume III: Table 5-1, Figure 5-1, Figure 5-2,
Figure 5-4, and xv6's struct trapframe.)
-->

<h2>Calling a System Call from User Space</h2>

<ul>
<li>Start with the <tt>exec</tt> in initcode.S
<li>What does the <tt>int 0x40</tt> instruction do?
</ul>

<p>
Execute the <tt>int</tt>. Now where are we? How did we get here?


<h2>The INT instruction</h2>

The x86 CPU supports 256 interrupt vectors. Different hardware
conditions produce interrupts through different vectors. The
kernel can tell why the interrupt occured by noting the vector.
The vector refers to an descriptor in the IDT. Each descriptor
contains a segment selector, an offset in that segment, and a DPL.

<p>
The INT instruction takes the following steps (these will
be similar to all interrupts and faults, though there are
slight differences):
<ol>
<li> decide the vector number, in this case it's the 0x40 in <tt>int 0x40</tt>.
<li> fetch the interrupt descriptor for vector 0x40 from the IDT. the CPU
finds it by taking the 0x40'th 8-byte entry starting at the physical
address that the IDTR CPU register points to.
<li> check that CPL <= DPL in the descriptor (but only if INT instruction).
<li> save ESP and SS in a CPU-internal register (but only if target segment selector's PL < CPL).
<li> load SS and ESP from TSS ("")
<li> push user SS ("")
<li> push user ESP ("")
<li> push user EFLAGS
<li> push user CS
<li> push user EIP
<li> clear some EFLAGS bits
<li> set CS and EIP from IDT descriptor's segment selector and offset
</ol>

INT is a complex instruction. Does it really need to take all those
steps? Why not let the kernel interrupt handler do some of them? For
example, why does INT need to save the SS and ESP?

<p>
xv6 set up the IDT in tvinit(), set the IDTR in idtinit(),
and set the SS and ESP in the TSS in usegment().
Check IDT 64 to see how the IDT is set up
to handle vector <tt>0x40</tt>.

<h2>Trap Handling</h2>

<tt>int 0x40</tt> entered the kernel at vector64, generated by vectors.pl.
<p>

What is the current CPL? How was it set? Could the user abuse
the <tt>INT</tt> instruction to exercise privilege or
break the kernel?

<p>
<tt>x/16x $esp</tt> in order to see what <tt>int</tt> put on
the stack. Compare to Figure 5-4. What stack is being used?

<p>
vector64 pushes a few items on the stack and then jumps to alltraps.
Why not have vector 64 in the IDT point directly to alltraps?

<p>
Single-step until the call to trap. <tt>x/18x $esp</tt>.
Compare with <tt>struct trapframe</tt>.

<p>
At the start of <tt>trap()</tt>, what is <tt>tf->trapno</tt>?
How was it set?

<h2>System call dispatch, arguments and return value</h2>

<tt>trap()</tt> calls syscall(), since trapno in this case
is T_SYSCALL (0x40).

<p>
syscall() dispatches to a function it finds by indexing into
the syscalls array. It uses the eax from the trap frame as
the index. What is in that eax? Where was it set?

<p>
Now we're in sys_open(). Where are the arguments the user
program originally passed to <tt>open()</tt>? How can
the kernel get at them?

<p>
sys_open() calls argint() to get its 2nd argument.
Argint calculates the value <tt>cp->tf_esp + 4 + 4*n</tt>.
What is this? Why the first 4? Why the <tt>4*n</tt>?

<p>
fetchint() checks that the address is not beyond the end of
user memory. But addr was just calculated by kernel code
(in argint()); since the kernel code is trustworthy, is this
check really neccessary?

<p>
Why do we do seemingly redundant checks for addr and then addr+4?
Can't we just check addr+4?

<p>
Why does fetchint() add <tt>p->mem</tt> to addr?

<p>
Back to sys_open(). It does its job (which we will talk about later)
and finally returns a file descriptor using the ordinary C return
statement. syscall() puts that return value in
<tt>cp->tf->eax</tt>. Why?

<h2>Trap Return</h2>

syscall() returns to trap(), and trap() returns to alltraps.
<tt>b "trap"+0x195</tt>, single-step until alltraps.
<tt>x/18x $esp</tt> to see the trap frame again.
What is different and why?

<p>
single-step until <tt>iret</tt>, <tt>x/5x $esp</tt>, single-step
into user space. Print the registers and stack. What will the return
value to the original call to <tt>open()</tt> be?

<p>
What would happen if a user program divided by zero? What if
kernel code divided by zero?

<p>
In Unix, traps often get translated into signals to the process.
Some traps, though, are (partially) handled internally by the
kernel -- which ones?

<p>
Some traps push an extra error code onto the stack (typically containing
the segment descriptor that caused a fault).  But this error code isn't
pushed by the INT instruction.  Can the user confuse the kernel by invoking
INT 0xc (or any other vector that usually pushes an error code)?  Why not?

<h2>Device Interrupts</h2>

Like system calls, except: devices generate them at any time, there
are no arguments in CPU registers, nothing to return to, usually can't
ignore them.  There is hardware on the motherboard to signal the CPU
when a device needs attention (e.g. the user has typed a character on
the keyboard). There's usually a separate vector for each device.
Let's look at the timer interrupt; the timer hardware generates an
interrupt 100 times per second so that the kernel can track the
passage of time and so the kernel can time-slice among multiple
running processes. The timer interrupts through vector 32.

<p>
<tt>p idt[32]</tt>, then set a breakpoint at vector32

<p>
<tt>x/20x $esp</tt>.
What was the CPU doing at the time of the interrupt?
What stack is being used?

<p>
The interrupt will have pushed different numbers of words on the
stack depending on whether the CPU was in user-space or the kernel;
how does <tt>iret</tt> know how many words to pop?

<p>
What prevents lots of interrupts from coming in all at once and
overflowing the kernel stack?  Print the registers; IF=0x200.
<tt>p idt[32]</tt>, <tt>p idt[64]</tt>.

<p>trap(), when it's called for a time interrupt, does just two
things: increment the ticks variable, and call wakeup. At the end of
trap, xv6 calls yield. as we will see, may cause the interrupt to
return in a different process!

<p>
<!--
XXX Turns out our kernel had a subtle security bug in the way it
handled traps...  <tt>vb 0x1b:0x11</tt>, run <tt>movdsgs</tt>,
step over breakpoints that aren't <tt>mov ax, ds</tt>,
<tt>dump_cpu</tt> and single-step.
<tt>dump_cpu</tt> after mov gs, then <tt>vb 0x1b:0x21</tt> to
break after <tt>sbrk</tt> returns, <tt>dump_cpu</tt> again.

<h2>JOS/PIOS</h2>

JOS has a rather different structure from xv6.

<p>
Since JOS does not use segmentation, where do traps vector in JOS?

<p>
JOS also has a very different kernel architecture: only one kernel
stack, as opposed to one per process in xv6.  The kernel is not
re-entrant (cannot be interrupted), so all IDT entries are
interrupt gates in JOS.

-->
</body>
</html>
