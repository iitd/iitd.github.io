<h1 id="symbolic-analysis-invariant-inference">Symbolic Analysis : Invariant Inference</h1>
<h2 id="guess-and-check">Guess-and-Check</h2>
<ol type="1">
<li>In the code below, what are some affine-equality invariants at the loop head and the loop tail that may relate the different variables <code>i</code>, <code>sum1</code>, and <code>sum2</code>?</li>
</ol>
<pre><code>int foo(int n)
{
  int sum1 = 0, sum2 = 0;
  for (int i = 0; i &lt; n; i++) {
    sum1 += i;
    sum2 = i*(i + 1);
  }
  assert(sum1 &gt;= n + 5);
  return sum1 + sum2;
}</code></pre>
<ol start="2" type="1">
<li>Hoare triple: {Precondition} Program {Postcondition}</li>
</ol>
<p>Some examples</p>
<pre><code>{x &gt; 0} y := x + 1 { x &gt; 0 and y &gt; 1 }
{x &gt; 0 and y--&gt;heap and *g1=0} *y := x { x &gt; 0 and y--&gt;heap and *g1=0 and *y &gt; 0 }
{x &gt; 0 and y--&gt;heap/g1 and *g1=0} *y := x { x &gt; 0 and y--&gt;heap/g1 and *g1&gt;=0 and *y &gt; 0 }</code></pre>
<ol start="3" type="1">
<li>How do you identify if this is indeed a valid loop invariant?</li>
</ol>
<pre><code>{Precondition}
while (condition) {
   //Candidate Loop Invariant
   LoopBody
}
{Postcondition}</code></pre>
<p>For a candidate loop invariant, check the following Hoare triples:</p>
<pre><code>{ Precondition } condition is true { Candidate Loop Invariant }
{ Candidate Loop Invariant } LoopBody ; condition is true { Candidate Loop Invariant}
{ Candidate Loop Invariant } condition is false { Postcondition }</code></pre>
<ol start="4" type="1">
<li>How should you set the precondition/postcondition? Depends on the application you are targetting.</li>
</ol>
<p>If you are interested in identifying the properties that would hold after the loop (e.g., for optimization or verification purposes), then you would set the precondition to whatever is known beginning from the start of the program.</p>
<p>If you are interested in identifying the precondition of a given assertion-failure, then you would set the postcondition to the assert-fail condition.</p>
<p>For the following example:</p>
<pre><code>int foo(int v, int w)
{
  x = v;
  a = w;
  while (c()) {
    //candidate
    x := x + 1;
    a := a - 1;
  }
  assert(x + a != 12);
}</code></pre>
<p>The required hoare triples are</p>
<pre><code>{Candidate} x:=x+1; a:=a-1; c() is true {Candidate}
{Candidate} x:=x+1; a:=a-1; c() is false {x + a == 12}</code></pre>
<p>Does the candidate “x+a == v + w” work?</p>
<p>What about “x+a == 12”?</p>
<p>The final precondition is: “v+w == 12”.</p>
<h2 id="data-driven">Data-driven</h2>
<p>A very relevant example relates to affine invariants:</p>
<ol type="1">
<li><p>The grammar of affine invariants is <code>c0+c1*x1+c2*x2+...+cn*xn = 0</code></p></li>
<li><p>Instrument the program to collect the concrete values of variables and the corresponding behaviour, e.g., does this set of values eventually led to an assertion failure. Each set of values can be called a <em>point</em>.</p></li>
<li><p>Identify the <em>smallest affine space</em> that contains these points, and use that as a candidate.</p></li>
<li><p>If the candidate does not satisfy all the Hoare triples, then try the <em>bigger affine spaces</em>. But, the number of bigger affine spaces can be too large to enumerate exhaustively. For example, a large number of distinct planes can pass through a line.</p></li>
</ol>
<h2 id="counterexample-guided">Counterexample-guided</h2>
<p>Again, we will use the example of affine invariants:</p>
<ol type="1">
<li><p>Start with the empty space</p></li>
<li><p>Check each hoare-triple. If all hoare triples are satisfied, we are done.</p></li>
<li><p>If some hoare triple is not satisfied, we get a counter-example</p></li>
<li><p>Use the counter-example to <em>enlarge the affine space</em> and goto step 2.</p></li>
</ol>
<p>Proof: For integer arithmetic, this process converges within N iterations where N is the number of variables (which are being attempted to be related through an affine invariant).</p>
<h1 id="symbolic-analysis-modeling-memory">Symbolic Analysis : Modeling Memory</h1>
<p>Memory is represented as an <em>array</em>. An array is a function that maps addresses to data, e.g., 32-bit address to 8-bit data. It additionally supports the <em>select</em> and <em>store</em> operations.</p>
<pre><code>select(store(A, a, d), a) == d</code></pre>
<p>However, this representation is usually not sufficient to model the state of a high-level program, e.g., a C program. In the abstract machine of a C program, the array is segmented into heap, stack, global variables, and local variables.</p>
<h2 id="segmenting-memory">Segmenting Memory</h2>
<p>For simplicity, we will first consider only the heap, stack, and global variables. Tackling local variables is slightly tricker because they can be dynamically allocated, and their static identification often requires reasoning about non-contiguous regions of memory. That said, our equivalence checker efficiently models dynamically-allocated local variables while supporting discontiguity, etc.</p>
<p>Each global variable can be identified by a start address and a size. Similarly, the stack can be identified by a start address and a (maximum) size. All other memory belongs to the heap. These constraints can be encoded by encoding the facts that the intervals defined by these <code>(start,size)</code> pairs do not intersect, while submitting them to the SAT/SMT solver. Further, we can encode aliasing constraints (e.g., <code>x</code> can only point within the heap) using similar logical conditions. When we get back the counter-example, it will respect the constraints we encoded using logical formulae.</p>
<p>Example:</p>
<pre><code>int g[100];
int f(int* p, int k, int m, int n, int o)
{
  int l[20];
  int* h = malloc(10);
  l[m] = p[n] + h[(m+n)/2] + 2;
  p[m] = 2*p[o];
  g[m-o] = 20;
  h[k] = 10;
}</code></pre>
<h1 id="side-channel-attacks">Side-Channel Attacks</h1>
<p>Examples of side-channels: time, power, radio-frequency, heat, cache misses, network messages, …</p>
<h2 id="timing-side-channel">Timing side-channel</h2>
<p>The time taken by a proram may leak some information about some secret that is used by the program for some processing. A timing-difference of say 1-2 microseconds is often enough for the attacker to obtain a reliable signal to be able to deconstruct (a part of) the secret bit-by-bit.</p>
<p>Simple example (also a part of your lab):</p>
<pre><code>int check_password(char const* input_password, char const* expected_password)
{
  char const* p = input_password;
  char const* q = expected_password;
  while (*p == *q) {
    //some computation that may take 1-2us
    if (*p == &#39;\0&#39;) {
      return 1; //paswwords match
    }
    p++;
    q++;
  }
  return 0; //passwords mismatch
}</code></pre>
<p>Invoke this function with different strings for <code>input_password</code> and time the program.</p>
<p>Researchers have shown that timing-based attacks can be remotely mounted over the network on the RSA implementations to identify 200 bits of a private key in Apache2/SSL.</p>
<h2 id="cache-based-side-channel">Cache-based side-channel</h2>
<p>If we can identify the accessed memory addresses as a function of a secret that is used for processing by a privileged proram, a concurrently running unprivileged program can profile the cache to identify the likely address that may have been accessed, and map it back to the possible bits of the secret key. e.g., content-based caching, memoization, etc.</p>
<pre><code>char secret[100];

foo() {
  // read/write a[secret[i]]
}</code></pre>
<p>If the attacker is able to co-locate on the same physical machine as the target, then the attacker can do one of the following two things:</p>
<h3 id="first-idea">First idea</h3>
<ol type="1">
<li><p>It can warm up all the cache lines with its own data, e.g., by repeately accessing all the addresses until the cache is full.</p></li>
<li><p>Then invoke the target on a carefully crafted input</p></li>
<li><p>Then read its own data back and time these reads. For reads that take longer than others, it is likely that those addresses have been accessed by the target too, which caused cache replacement of the attacker’s data for those reads.</p></li>
<li><p>By carefully analyzing this cache-timing information, it can try and reconstruct the secret (on which the memory accesses may depend).</p></li>
</ol>
<h3 id="second-idea">Second idea</h3>
<p>If the attacker and target can possibly share common pages, e.g., they are running in the same address space (e.g., sharing a common service), then:</p>
<ol type="1">
<li><p>Instead of warming the cache, first flush the cache</p></li>
<li><p>Get the target to run</p></li>
<li><p>Access all the memory regions that <em>may</em> have been accessed by the target, and profile these accesses. The data that was brought in the cache by the target will be accessed faster.</p></li>
</ol>
<h3 id="mitigation">Mitigation</h3>
<p>Ensure in software that the accessed memory addresses and CPU usage are mostly independent of the secret key.</p>
<h2 id="spectre-v1">Spectre V1</h2>
<p>Let’s say that that the memory of the target contains public data and secret data stored close to each other. Also, let’s say that the accessed memory addresses depend on some of the public data.</p>
<pre><code>char public[10];
char secret[100];

foo() {
  // read/write a[public[i]] in a loop
}</code></pre>
<p>But as a prefetching/speculative mechanism, the hardware processor may also read <code>a[secret[j]]</code> for small values of <code>j</code>. This can allow the attacker to mount cache-line based side-channel attacks even though the software program was careful to not allow memory accesses to be a function of the secret.</p>
